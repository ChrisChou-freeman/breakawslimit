project break aws limit
=========================

关于:
----------

- aws iot 证书注册以及策略更新api服务整合
- 圆滑过度请求，利用每个请求的额度，并保存任务进度
- 可配置的每秒额度上下限
- 基于微服务架构,由[Grpc](https://grpc.io)实现

微服务演示代码:
---------------

  [gitlab](http://gitlab.sugrsugr.com/ChrisChou/grpcmicserverexample)

设计图:
--------------

  [设计思路](https://www.processon.com/view/link/5ef2aadee0b34d4dba522703)


项目构建思路
--------------

由于iot服务相关的接口每个都有不一样的每秒请求限制, 当你的请求服务不加限制的请求后将会返回失败，失败理由是aws请求资源上限的限制错误，为了最大化的利用分配的每个请求额度上限并保证任务能够顺利的一次完成，故将
每种服务类型进行拆分处理,作为异步队列任务以最大化的利用到每个请求的额度上限。

比如创建证书服务，可以拆分为

* 注册你的设备证书
* 将证书附加到thing上
* 查看要创建的policyName是否已经创建(如果证书不存在则跳到注册policy这一步)
* 如果policy存在则解绑
* 如果policy存在解绑成功则删除
* 注册policy
* 将policy绑定到thing上


异步队列的生成原理
------------------

所有的队列都由redis来模拟队列实现，由于初始业务量不够大所以队列的实现暂时用redis来模拟，将来业务量并发超过百万级别的时候，需要考虑使用专业的一步详细队列来实现更加复杂的业务需求。

每种服务和对应的细节处理任务都由配置文件conf.js下面的queueConfig配置，每种服务对应一个数组，每个数组的成员解释

* name: 任务的名称，同时也是redis的队列名称，将其以单下划线切割后取索引1为模块下任务函数的反射名称，这也是为了减少不必要重复代码量而做的处理
* drawData: 需要放进任务函数的值有哪些，具体会根据是否有子任务，比如listTargetsForPolicy由于需要检查所有需要创建的policyName是否存在，则会生成子任务情况进行特殊处理。具体看代码吧
* putArgs: 需要为下一个队列任务放入队列数据的值, 同样对是否有子任务进行特殊处理
* subMession: 需要生成子任务的数据对象名称
* jumpCondition: 如其名，设置跳跃条件。比如在创建证书检查是否已经存在policyName的情况，不存在的话跳跃到注册位置


异步任务处理并返回机制原理
--------------------

由于会将每种请求的服务拆分成若干的任务丢进redis队列中，再针对性的进行处理，所以你无法直接等待任务的执行结束再返回，所以会将每个任务的数据进行md5值的生成，对该md5创建事件后监听，等待任务走完最后一个队列后就会将该事件触发，并返回给客户端

事件类型:

* taskSuccessEvent
* taskErrEvent


异步任务队列的运行机制
----------------------

每种被拆分服务的任务，都有自己对应的队列名称。每个队列名称切割后又是任务函数的名称，也对应了aws服务名称的limit变量名。所以我想出了一个定时遍历所以的队列名称根据名称取得任务，在取得对应任务函数，再判断是否有额度的方法来省去重复的代码方法。再每个队列执行中的时候将标记为执行中，执行中的队列将不会重复执行，任务执行完毕后解除标记。具体看函数‘runConfigTask’ 和'sendTask' 


